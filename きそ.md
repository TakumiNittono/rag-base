# RAGシステム 要件定義書

## 文書情報

| 項目 | 内容 |
|------|------|
| 文書名 | RAGシステム 要件定義書 |
| バージョン | 1.0 |
| 作成日 | 2024年 |
| 最終更新日 | 2024年 |
| 対象システム | RAGベース検索システム（管理者機能付き） |

---

## 1. プロジェクト概要

### 1.1 目的

本システムは、ファイルベースのRAG（Retrieval-Augmented Generation）検索システムを提供する。管理者がファイルをアップロード・管理し、一般ユーザーが自然言語で質問してRAG検索を実行できる。

### 1.2 設計思想

- **拡張性**: 構成を壊さずに機能追加が可能な設計
- **技術独立性**: 各レイヤーを独立させ、技術選定を後から差し替え可能
- **スケーラビリティ**: MVPから業務システムへ自然に移行可能
- **保守性**: 明確な責務分離により、理解しやすく保守しやすい構造

### 1.3 スコープ

**本バージョンで実装する機能:**
- ユーザー認証（Supabase Auth）
- ファイルアップロード・削除（管理者）
- RAG検索（一般ユーザー）
- ファイル管理画面（管理者）

**本バージョンで実装しない機能:**
- ファイル編集・更新機能
- バージョン管理
- フォルダ構造
- ユーザー別RAG
- 会話履歴の永続化
- アクセスログ・監査ログ

---

## 2. システムアーキテクチャ

### 2.1 全体構成

```
┌─────────────────────────────────────────────────────────┐
│                    UI Layer                              │
│  Azure Static Web Apps                                   │
│    ├─ /          (一般ユーザー: チャット画面)            │
│    └─ /admin     (管理者: ファイル管理画面)              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    API Layer                             │
│  Azure Functions (Python / FastAPI構成)                 │
│    ├─ /api/auth      (認証関連)                         │
│    ├─ /api/chat      (RAG検索)                          │
│    ├─ /api/admin/*   (管理API)                          │
│    └─ /api/health    (ヘルスチェック)                    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│              Application Layer                           │
│  RAG Service (LlamaIndex)                                │
│    ├─ Retriever      (ベクトル検索)                      │
│    ├─ Index Manager  (インデックス管理)                  │
│    ├─ Chunker        (テキスト分割)                      │
│    └─ Prompt Builder (プロンプト構築)                    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    Data Layer                            │
│  Supabase                                                │
│    ├─ Auth          (認証・ユーザー管理)                 │
│    ├─ PostgreSQL    (メタデータ・ベクトル)               │
│    │   └─ pgvector  (ベクトル検索)                      │
│    └─ Storage       (ファイル保存)                      │
└─────────────────────────────────────────────────────────┘
```

### 2.2 レイヤー分離の原則

各レイヤーは完全に独立し、以下の原則に従う：

- **UI Layer**: APIエンドポイントのみに依存。フロントエンドフレームワークは後から変更可能
- **API Layer**: Application Layerのインターフェースのみに依存。実装は後から変更可能
- **Application Layer**: Data Layerの抽象化されたインターフェースに依存
- **Data Layer**: データストアの実装は後から変更可能（例: PostgreSQL → Azure AI Search）

### 2.3 データフロー

#### 2.3.1 ファイルアップロードフロー（Lv2.5: 3テーブル分離設計）

```
管理者 → UI (/admin) 
  → API (/api/admin/upload)
    → RAG Service (ingest_file)
      → Storage (ファイル保存)
      → DB (filesテーブル: メタデータ保存、status='uploaded')
      → RAG Service (テキスト抽出・分割)
        → DB (chunksテーブル: テキストチャンク保存)
        → DB (filesテーブル: status='indexing'に更新)
      → RAG Service (Embedding生成)
        → DB (embeddingsテーブル: ベクトル表現保存)
        → DB (filesテーブル: status='indexed'、embedding_count更新)
```

#### 2.3.2 RAG検索フロー（Lv2.5: 3テーブル分離設計）

```
一般ユーザー → UI (/) 
  → API (/api/chat)
    → RAG Service (retrieve)
      → Embedding生成 (質問文)
      → DB (embeddingsテーブル: ベクトル類似検索)
      → DB (chunksテーブル: JOINしてテキスト取得)
      → DB (filesテーブル: JOINしてファイル情報取得)
    → RAG Service (generate_answer)
      → LLM (OpenAI API)
        → UI (回答表示)
```

---

## 3. 技術スタック

### 3.1 フロントエンド

| 技術 | バージョン | 用途 | 選定理由 |
|------|-----------|------|----------|
| Azure Static Web Apps | - | ホスティング | URL分岐が容易、API統合が自然、将来React/Next.jsに移行可能 |

**UIフレームワーク**: Bootstrap または 素HTML（MVP段階）

### 3.2 バックエンド

| 技術 | バージョン | 用途 | 選定理由 |
|------|-----------|------|----------|
| Azure Functions | Python 3.11+ | APIサーバー | ローカルと本番の乖離が少ない、将来Container/App Serviceへ移行可能 |
| FastAPI | 0.104+ | APIフレームワーク | 型安全性、自動ドキュメント生成、非同期処理対応 |

### 3.3 RAG・LLM

| 技術 | バージョン | 用途 | 選定理由 |
|------|-----------|------|----------|
| LlamaIndex | 0.9+ | RAGフレームワーク | Retriever/Index/Storageの抽象化、Vector DB差し替えが容易 |
| OpenAI API | - | LLM・Embedding | GPT-4o-mini（チャット）、text-embedding-3-small（Embedding） |

### 3.4 データベース・ストレージ

| 技術 | バージョン | 用途 | 選定理由 |
|------|-----------|------|----------|
| Supabase PostgreSQL | - | メタデータ・ベクトル保存 | 初期コスト0、本番でも通用、Azure PostgreSQL/Pinecone/AI Searchに移行可 |
| pgvector | 0.5+ | ベクトル検索拡張 | PostgreSQL標準的なベクトル検索 |
| Supabase Storage | - | ファイル保存 | 認証統合が容易、将来Azure Blob Storageへ移行可 |

### 3.5 認証

| 技術 | バージョン | 用途 | 選定理由 |
|------|-----------|------|----------|
| Supabase Auth | - | ユーザー認証・認可 | JWT標準、RLS・RBACへ自然拡張、Azure AD/Entra ID連携も可能 |

---

## 4. ユーザー・権限設計

### 4.1 ロール定義

| ロール | 権限 | 説明 |
|--------|------|------|
| `user` | チャット検索 | 一般ユーザー。RAG検索のみ実行可能 |
| `admin` | ファイル管理 | 管理者。ファイルのアップロード・削除・一覧表示が可能 |

### 4.2 認証・認可の実装

**認証方式:**
- Supabase AuthによるEmail/Password認証
- JWTトークンによるセッション管理

**認可方式:**
- JWTの`email`または`role`クレームによる判定
- 管理者判定: 環境変数`ADMIN_EMAILS`に含まれるメールアドレス
- RLS（Row Level Security）は本バージョンでは未使用（将来拡張可能）

**将来拡張可能なロール:**
- `team`: チーム単位での権限管理
- `tenant`: マルチテナント対応
- `viewer`: 閲覧専用権限

---

## 5. 機能要件

### 5.1 一般ユーザー機能

#### 5.1.1 認証機能

**機能ID**: F-USER-001

**概要**: ユーザーはEmail/Passwordでログインできる

**詳細**:
- ログイン画面（`/login`）を提供
- Supabase Authを使用した認証
- 認証成功後、JWTトークンを保存
- 未認証ユーザーは`/login`にリダイレクト
- 認証済みユーザーは`/`（チャット画面）にアクセス可能

**入力**:
- Email（必須、メールアドレス形式）
- Password（必須、8文字以上）

**出力**:
- 認証成功: JWTトークン、ユーザー情報
- 認証失敗: エラーメッセージ

**エラーハンドリング**:
- 無効なメールアドレス形式
- パスワード不一致
- アカウント不存在
- ネットワークエラー

#### 5.1.2 RAGチャット検索機能

**機能ID**: F-USER-002

**概要**: ユーザーは自然言語で質問し、RAG検索結果に基づいた回答を受け取れる

**詳細**:
- チャット画面（`/`）で質問を入力
- 質問をAPIに送信
- RAG検索を実行（ベクトル類似検索）
- 検索結果をコンテキストとしてLLMに送信
- 生成された回答を表示
- 会話履歴はセッション内のみ保持（ページリロードで消失）

**入力**:
- 質問テキスト（必須、最大2000文字）

**出力**:
- 回答テキスト
- 参考にしたチャンクの情報（オプション）

**処理フロー**:
1. JWT検証
2. 質問文のEmbedding生成
3. pgvectorによる類似検索（TOP_K=5）
4. 検索結果をコンテキストとして構築
5. LLM（GPT-4o-mini）で回答生成
6. 回答を返却

**エラーハンドリング**:
- 認証エラー（401）
- 質問が空
- 検索結果が0件
- LLM APIエラー
- タイムアウト（30秒）

### 5.2 管理者機能

#### 5.2.1 アクセス制御

**機能ID**: F-ADMIN-001

**概要**: 管理者以外は`/admin`にアクセスできない

**詳細**:
- `/admin`へのアクセス時にJWT検証
- JWTの`email`が`ADMIN_EMAILS`に含まれるか確認
- 管理者でない場合、403エラーを表示
- 未認証の場合は`/login`にリダイレクト

#### 5.2.2 ファイルアップロード機能

**機能ID**: F-ADMIN-002

**概要**: 管理者はファイルをアップロードし、RAG検索対象として登録できる

**詳細**:
- ファイル選択UIを提供
- 対応ファイル形式:
  - `.txt`（テキストファイル）
  - `.md`（Markdown）
  - `.pdf`（PDF、テキスト抽出のみ）
- ファイルサイズ制限: 10MB以下
- アップロード処理（Lv2.5: 3テーブル分離設計）:
  1. Supabase Storageに保存
  2. ファイルメタデータを`files`テーブルに登録（status='uploaded'）
  3. テキスト抽出
  4. チャンク分割（CHUNK_SIZE=500文字、オーバーラップ=50文字）
  5. `chunks`テーブルにテキストチャンクを保存（status='indexing'に更新）
  6. Embedding生成（text-embedding-3-small）
  7. `embeddings`テーブルにベクトル表現を保存
  8. `files`テーブルのstatusを'indexed'、embedding_countを更新

**入力**:
- ファイル（multipart/form-data）

**出力**:
- ファイルID（UUID）
- ファイル名
- ステータス（uploaded / indexing / indexed / error）

**エラーハンドリング**:
- 未対応ファイル形式
- ファイルサイズ超過
- テキスト抽出失敗（PDF）
- Embedding生成エラー
- ストレージ保存エラー

#### 5.2.3 ファイル一覧表示機能

**機能ID**: F-ADMIN-003

**概要**: 管理者はアップロード済みファイルの一覧を確認できる

**詳細**:
- ファイル一覧テーブルを表示
- 表示項目:
  - ファイル名
  - アップロード日時
  - ステータス（uploaded / indexing / indexed / error）
  - チャンク数（indexedの場合）
  - ファイルサイズ（オプション）
- 一覧はアップロード日時の降順でソート

**入力**: なし

**出力**: ファイル一覧（JSON配列）

#### 5.2.4 ファイル削除機能

**機能ID**: F-ADMIN-004

**概要**: 管理者はファイルを削除できる

**詳細**:
- ファイルIDを指定して削除
- 削除処理（Lv2.5: 3テーブル分離設計）:
  1. Supabase Storageからファイル削除
  2. `embeddings`テーブルから該当チャンクのEmbeddingを削除（CASCADE）
  3. `chunks`テーブルから該当ファイルのチャンクを削除（CASCADE）
  4. `files`テーブルからファイルレコードを削除
- 削除は不可逆（復元不可）

**入力**:
- ファイルID（UUID、必須）

**出力**:
- 削除成功メッセージ

**エラーハンドリング**:
- ファイルID不存在
- ストレージ削除エラー
- DB削除エラー

**注意事項**:
- ファイルの編集・更新機能は提供しない
- 更新が必要な場合は削除→再アップロードを推奨

---

## 6. API仕様

### 6.1 共通仕様

**ベースURL**: `https://<function-app-name>.azurewebsites.net/api`

**認証方式**: Bearer認証（JWT）
```
Authorization: Bearer <jwt_token>
```

**レスポンス形式**: JSON

**エラーレスポンス形式**:
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "エラーメッセージ",
    "details": {}
  }
}
```

**HTTPステータスコード**:
- 200: 成功
- 201: 作成成功
- 400: リクエストエラー
- 401: 認証エラー
- 403: 権限エラー
- 404: リソース不存在
- 500: サーバーエラー

### 6.2 エンドポイント一覧

#### 6.2.1 POST /api/chat

**概要**: RAG検索を実行し、回答を生成

**認証**: 必須（一般ユーザー以上）

**リクエスト**:
```json
{
  "message": "社内の有給ルールを教えて"
}
```

**レスポンス（成功）**:
```json
{
  "answer": "社内の有給ルールについて...",
  "sources": [
    {
      "file_id": "uuid",
      "file_name": "有給規則.md",
      "chunk_id": "uuid",
      "content": "チャンクの一部..."
    }
  ]
}
```

**レスポンス（エラー）**:
```json
{
  "error": {
    "code": "NO_RESULTS",
    "message": "検索結果が見つかりませんでした"
  }
}
```

#### 6.2.2 GET /api/health

**概要**: システムのヘルスチェック

**認証**: 不要

**レスポンス**:
```json
{
  "status": "healthy",
  "timestamp": "2024-01-01T00:00:00Z"
}
```

#### 6.2.3 POST /api/admin/upload

**概要**: ファイルをアップロードし、RAG検索対象として登録

**認証**: 必須（管理者のみ）

**リクエスト**: `multipart/form-data`
- `file`: ファイル（必須）

**レスポンス（成功）**:
```json
{
  "file_id": "uuid",
  "file_name": "example.txt",
  "status": "indexing",
  "created_at": "2024-01-01T00:00:00Z"
}
```

**レスポンス（エラー）**:
```json
{
  "error": {
    "code": "INVALID_FILE_TYPE",
    "message": "サポートされていないファイル形式です"
  }
}
```

#### 6.2.4 GET /api/admin/files

**概要**: アップロード済みファイルの一覧を取得

**認証**: 必須（管理者のみ）

**クエリパラメータ**:
- `status`: フィルタ（オプション、uploaded/indexing/indexed/error）
- `limit`: 取得件数（オプション、デフォルト: 100）
- `offset`: オフセット（オプション、デフォルト: 0）

**レスポンス（成功）**:
```json
{
  "files": [
    {
      "id": "uuid",
      "file_name": "example.txt",
      "status": "indexed",
      "chunk_count": 10,
      "created_at": "2024-01-01T00:00:00Z"
    }
  ],
  "total": 1
}
```

#### 6.2.5 POST /api/admin/delete

**概要**: ファイルを削除

**認証**: 必須（管理者のみ）

**リクエスト**:
```json
{
  "file_id": "uuid"
}
```

**レスポンス（成功）**:
```json
{
  "message": "ファイルが削除されました",
  "file_id": "uuid"
}
```

**レスポンス（エラー）**:
```json
{
  "error": {
    "code": "FILE_NOT_FOUND",
    "message": "指定されたファイルが見つかりません"
  }
}
```

---

## 7. データモデル設計（Lv2.5: 3テーブル分離設計）

### 7.1 設計思想

**Lv2.5の特徴**:
- `files`、`chunks`、`embeddings`の3テーブルに完全分離
- チャンク（テキスト）とEmbedding（ベクトル）を独立管理
- Embeddingモデル変更時にEmbeddingのみ再生成可能
- チャンク更新とEmbedding更新を分離可能
- 将来の拡張性・保守性が向上

**テーブル関係**:
```
files (1) ──→ (N) chunks (1) ──→ (1) embeddings
```

### 7.2 データベーススキーマ

#### 7.2.1 filesテーブル

ファイルのメタデータを管理するテーブル。

```sql
CREATE TABLE files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  file_name TEXT NOT NULL,
  storage_path TEXT NOT NULL,
  file_size BIGINT,
  mime_type TEXT,
  status TEXT NOT NULL DEFAULT 'uploaded',
  -- status: 'uploaded' | 'indexing' | 'indexed' | 'error'
  error_message TEXT,
  chunk_count INTEGER DEFAULT 0,
  embedding_count INTEGER DEFAULT 0,
  -- embedding_count: 実際にEmbeddingが生成されたチャンク数
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  CONSTRAINT status_check CHECK (status IN ('uploaded', 'indexing', 'indexed', 'error'))
);

CREATE INDEX idx_files_status ON files(status);
CREATE INDEX idx_files_created_at ON files(created_at DESC);
```

**カラム説明**:
- `id`: ファイルの一意識別子（UUID）
- `file_name`: ファイル名
- `storage_path`: Supabase Storage内のパス
- `file_size`: ファイルサイズ（バイト）
- `mime_type`: MIMEタイプ
- `status`: 処理ステータス
- `error_message`: エラー発生時のメッセージ
- `chunk_count`: チャンク数（テキスト分割後）
- `embedding_count`: Embedding生成済みチャンク数（indexedの場合）
- `created_at`: 作成日時
- `updated_at`: 更新日時

#### 7.2.2 chunksテーブル

ファイルを分割したテキストチャンクを保存するテーブル（Embeddingは含まない）。

```sql
CREATE TABLE chunks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  file_id UUID NOT NULL REFERENCES files(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  chunk_index INTEGER NOT NULL,
  -- chunk_index: ファイル内でのチャンクの順序（0始まり）
  token_count INTEGER,
  -- token_count: チャンクのトークン数（オプション、将来の最適化用）
  created_at TIMESTAMP DEFAULT now(),
  CONSTRAINT chunk_index_check CHECK (chunk_index >= 0)
);

CREATE INDEX idx_chunks_file_id ON chunks(file_id);
CREATE INDEX idx_chunks_file_id_index ON chunks(file_id, chunk_index);
```

**カラム説明**:
- `id`: チャンクの一意識別子（UUID）
- `file_id`: 親ファイルのID（外部キー）
- `content`: チャンクのテキスト内容
- `chunk_index`: ファイル内でのチャンクの順序（0始まり）
- `token_count`: チャンクのトークン数（将来の最適化用、オプション）
- `created_at`: 作成日時

**設計思想**:
- テキストチャンクのみを管理（Embeddingは別テーブル）
- チャンクの内容変更が容易
- Embedding生成の失敗時もチャンクは保持

#### 7.2.3 embeddingsテーブル

チャンクのベクトル表現（Embedding）を保存するテーブル。

```sql
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chunk_id UUID NOT NULL REFERENCES chunks(id) ON DELETE CASCADE,
  embedding VECTOR(1536) NOT NULL,
  -- 1536次元: text-embedding-3-small
  model_name TEXT NOT NULL DEFAULT 'text-embedding-3-small',
  -- model_name: Embeddingモデル名（将来のモデル変更に対応）
  created_at TIMESTAMP DEFAULT now(),
  CONSTRAINT unique_chunk_embedding UNIQUE (chunk_id, model_name)
  -- 1チャンクにつき1モデルで1つのEmbedding（将来のマルチモデル対応）
);

CREATE INDEX idx_embeddings_chunk_id ON embeddings(chunk_id);
CREATE INDEX idx_embeddings_model ON embeddings(model_name);
CREATE INDEX idx_embeddings_vector ON embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
-- ivfflatはpgvectorのインデックス（検索高速化）
```

**カラム説明**:
- `id`: Embeddingの一意識別子（UUID）
- `chunk_id`: 対応するチャンクのID（外部キー）
- `embedding`: ベクトル表現（1536次元、text-embedding-3-small）
- `model_name`: Embeddingモデル名（将来のモデル変更・比較に対応）
- `created_at`: 作成日時

**設計思想**:
- Embeddingを独立テーブルで管理
- Embeddingモデル変更時にEmbeddingのみ再生成可能
- 1チャンクに複数モデルのEmbeddingを保持可能（将来拡張）
- ベクトル検索はこのテーブルで実行

**Lv2.5の利点**:
1. **柔軟性**: チャンクとEmbeddingを独立して更新可能
2. **拡張性**: 複数のEmbeddingモデルを同時保持可能
3. **保守性**: Embedding生成失敗時もチャンクは保持
4. **パフォーマンス**: Embeddingテーブルのみにインデックスを作成
5. **将来対応**: Embeddingモデルのアップグレードが容易

### 7.2 Supabase Storage構造

**バケット名**: `documents`

**パス構造**:
```
documents/
  {file_id}/
    {file_name}
```

例: `documents/550e8400-e29b-41d4-a716-446655440000/example.txt`

---

## 8. RAG処理設計

### 8.1 RAG Serviceアーキテクチャ（Lv2.5: 3テーブル分離設計）

```
RAGService
  ├─ ingest_file(file_path, file_id)
  │   ├─ loader (ファイル形式に応じたローダー)
  │   ├─ chunker (テキスト分割)
  │   ├─ save_chunks (chunksテーブルに保存)
  │   ├─ embedder (Embedding生成)
  │   └─ save_embeddings (embeddingsテーブルに保存)
  │
  ├─ retrieve(query: str, top_k: int = 5)
  │   ├─ query_embedding (質問のEmbedding生成)
  │   └─ vector_search (embeddingsテーブルで類似検索)
  │       └─ JOIN chunks + files (テキストとメタデータ取得)
  │
  └─ generate_answer(query: str, contexts: List[str])
      ├─ prompt_builder (プロンプト構築)
      └─ llm_call (OpenAI API呼び出し)
```

**Lv2.5の処理フロー**:
1. **ファイル取り込み**:
   - テキスト抽出 → チャンク分割 → `chunks`テーブル保存
   - Embedding生成 → `embeddings`テーブル保存
   - 各ステップでエラーが発生しても、前のステップのデータは保持

2. **検索**:
   - `embeddings`テーブルでベクトル検索
   - `chunks`テーブルとJOINしてテキスト取得
   - `files`テーブルとJOINしてファイル情報取得

### 8.2 チャンキング戦略

**パラメータ**:
- `chunk_size`: 500文字
- `chunk_overlap`: 50文字
- `separator`: `\n\n`（段落区切りを優先）

**実装**:
- LlamaIndexの`SentenceSplitter`または`TokenTextSplitter`を使用
- ファイル形式に応じて適切なセパレータを選択

### 8.3 Embedding生成

**モデル**: `text-embedding-3-small`（OpenAI）

**次元数**: 1536

**実装**:
- LlamaIndexの`OpenAIEmbedding`を使用
- バッチ処理で効率化（最大100チャンク/バッチ）

### 8.4 ベクトル検索

**アルゴリズム**: コサイン類似度（pgvector）

**検索パラメータ**:
- `top_k`: 5（デフォルト）
- 類似度閾値: 0.7以上（オプション）
- `model_name`: Embeddingモデル名（デフォルト: 'text-embedding-3-small'）

**実装（Lv2.5: 3テーブル分離設計）**:
```sql
SELECT 
  c.id AS chunk_id,
  c.content,
  c.chunk_index,
  c.file_id,
  f.file_name,
  e.id AS embedding_id,
  1 - (e.embedding <=> $1::vector) AS similarity
FROM embeddings e
JOIN chunks c ON e.chunk_id = c.id
JOIN files f ON c.file_id = f.id
WHERE f.status = 'indexed'
  AND e.model_name = 'text-embedding-3-small'
ORDER BY e.embedding <=> $1::vector
LIMIT 5;
```

**検索フロー**:
1. 質問文のEmbedding生成（text-embedding-3-small）
2. `embeddings`テーブルでベクトル類似検索
3. `chunks`テーブルとJOINしてテキスト内容を取得
4. `files`テーブルとJOINしてファイル情報を取得
5. 類似度順にソートしてTOP_K件を返却

### 8.5 プロンプト設計

**テンプレート**:
```
以下のコンテキスト情報を基に、ユーザーの質問に回答してください。

コンテキスト:
{contexts}

質問: {query}

回答:
```

**実装**:
- LlamaIndexの`PromptTemplate`を使用
- コンテキストは最大2000トークンに制限

### 8.6 LLM呼び出し

**モデル**: `gpt-4o-mini`（OpenAI）

**パラメータ**:
- `temperature`: 0.7
- `max_tokens`: 1000
- `top_p`: 0.9

---

## 9. セキュリティ要件

### 9.1 認証・認可

- すべてのAPIエンドポイント（`/api/health`を除く）でJWT認証を必須とする
- JWTトークンの有効期限: 1時間（リフレッシュトークン: 7日）
- 管理者機能は`ADMIN_EMAILS`によるホワイトリスト方式
- CORS設定: 許可するオリジンのみ（本番環境）

### 9.2 データ保護

- ファイルアップロード時のサイズ制限: 10MB
- ファイル形式の検証（拡張子・MIMEタイプ）
- SQLインジェクション対策: パラメータ化クエリの使用
- XSS対策: フロントエンドでの入力値サニタイズ

### 9.3 APIセキュリティ

- レート制限: 100リクエスト/分/ユーザー（将来実装）
- タイムアウト: 30秒
- エラーメッセージに機密情報を含めない

### 9.4 ストレージセキュリティ

- Supabase Storageのバケットポリシー: 認証済みユーザーのみアクセス可能
- ファイルパスにUUIDを使用し、推測困難にする

---

## 10. 非機能要件

### 10.1 パフォーマンス

- APIレスポンス時間: 平均2秒以内（RAG検索）
- ファイルアップロード: 10MBファイルで30秒以内（同期処理の場合）
- 同時接続数: 100ユーザー（初期）

### 10.2 可用性

- 稼働率目標: 99%（MVP段階）
- メンテナンス時間: 週1回、30分以内

### 10.3 スケーラビリティ

- ファイル数: 1000ファイルまで対応（初期）
- チャンク数: 10万チャンクまで対応（初期）
- 将来の拡張: Azure AI Searchへの移行を想定

### 10.4 保守性

- コードの可読性: 型ヒント、docstringの記述
- ログ出力: エラーログ、アクセスログ（将来実装）
- モニタリング: Azure Application Insights（将来実装）

---

## 11. UI/UX要件

### 11.1 一般ユーザー画面（/）

**レイアウト**:
- ヘッダー: ログアウトボタン
- メイン: チャットエリア
  - メッセージ入力欄
  - 送信ボタン
  - 会話履歴表示エリア

**UI要件**:
- レスポンシブデザイン（モバイル対応）
- ローディング表示（API呼び出し中）
- エラーメッセージ表示

### 11.2 管理者画面（/admin）

**レイアウト**:
- ヘッダー: ログアウトボタン、一般画面へのリンク
- メイン:
  - ファイルアップロードエリア
  - ファイル一覧テーブル
  - 削除ボタン（各行）

**UI要件**:
- ファイル選択UI（ドラッグ&ドロップ対応）
- アップロード進捗表示
- ステータス表示（色分け）
- 確認ダイアログ（削除時）

### 11.3 ログイン画面（/login）

**レイアウト**:
- メイン: ログインフォーム
  - Email入力欄
  - Password入力欄
  - ログインボタン

**UI要件**:
- バリデーションエラー表示
- パスワード表示/非表示切り替え

---

## 12. 環境変数・設定

### 12.1 必須環境変数

```bash
# Supabase
SUPABASE_URL=https://<project>.supabase.co
SUPABASE_ANON_KEY=<anon_key>
SUPABASE_SERVICE_ROLE_KEY=<service_role_key>
SUPABASE_STORAGE_BUCKET=documents

# データベース（Supabase PostgreSQL）
DB_HOST=<host>
DB_PORT=5432
DB_NAME=postgres
DB_USER=postgres
DB_PASSWORD=<password>

# OpenAI
OPENAI_API_KEY=<api_key>

# RAG設定
EMBEDDING_MODEL=text-embedding-3-small
CHAT_MODEL=gpt-4o-mini
CHUNK_SIZE=500
CHUNK_OVERLAP=50
TOP_K=5

# 管理者設定
ADMIN_EMAILS=admin@example.com,foo@bar.com

# Azure Functions
AZURE_FUNCTIONS_ENVIRONMENT=production
```

### 12.2 オプション環境変数

```bash
# ログレベル
LOG_LEVEL=INFO

# CORS
ALLOWED_ORIGINS=https://<static-web-app>.azurestaticapps.net

# タイムアウト
API_TIMEOUT=30

# ファイルサイズ制限（バイト）
MAX_FILE_SIZE=10485760  # 10MB
```

---

## 13. エラーハンドリング

### 13.1 エラーコード一覧

| コード | HTTPステータス | 説明 |
|--------|---------------|------|
| `AUTH_REQUIRED` | 401 | 認証が必要 |
| `AUTH_INVALID` | 401 | 認証トークンが無効 |
| `FORBIDDEN` | 403 | 権限不足 |
| `INVALID_REQUEST` | 400 | リクエストが不正 |
| `FILE_NOT_FOUND` | 404 | ファイルが見つからない |
| `INVALID_FILE_TYPE` | 400 | 未対応のファイル形式 |
| `FILE_TOO_LARGE` | 400 | ファイルサイズ超過 |
| `EXTRACTION_FAILED` | 500 | テキスト抽出失敗 |
| `EMBEDDING_FAILED` | 500 | Embedding生成失敗 |
| `NO_RESULTS` | 404 | 検索結果なし |
| `LLM_ERROR` | 500 | LLM APIエラー |
| `DATABASE_ERROR` | 500 | データベースエラー |
| `STORAGE_ERROR` | 500 | ストレージエラー |
| `INTERNAL_ERROR` | 500 | 内部エラー |

### 13.2 エラーログ

- すべてのエラーをログに記録
- エラーログには以下を含める:
  - エラーコード
  - エラーメッセージ
  - スタックトレース（開発環境のみ）
  - リクエストID（トレーシング用）

---

## 14. テスト要件

### 14.1 単体テスト

- RAG Serviceの各メソッド
- チャンキングロジック
- Embedding生成
- ベクトル検索

### 14.2 統合テスト

- APIエンドポイントの動作確認
- ファイルアップロード→検索の一連の流れ
- 認証・認可の動作確認

### 14.3 E2Eテスト（将来実装）

- ユーザーシナリオ: ログイン→検索
- 管理者シナリオ: ログイン→アップロード→削除

---

## 15. デプロイ要件

### 15.1 デプロイ環境

- **開発環境**: ローカル開発（Azure Functions Core Tools）
- **本番環境**: Azure Static Web Apps + Azure Functions

### 15.2 デプロイ手順（概要）

1. Supabaseプロジェクト作成・設定
2. データベーススキーマ作成
3. Storageバケット作成
4. Azure Functionsデプロイ
5. Azure Static Web Appsデプロイ
6. 環境変数設定

### 15.3 ロールバック計画

- デプロイ前のバックアップ取得
- 前バージョンへのロールバック手順の文書化

---

## 16. 将来の拡張計画

### 16.1 Phase 2（短期）

- 会話履歴の永続化
- 管理者権限の細分化（viewer/admin）
- ファイル形式追加（Word / Excel）
- バッチ処理による非同期インデックス作成

### 16.2 Phase 3（中期）

- マルチテナント対応
- Azure AI Searchへの移行
- ログ・監査機能
- レート制限の実装

### 16.3 Phase 4（長期）

- iOS / Android アプリ
- 社内SSO（Entra ID）連携
- 高度なRAG機能（Re-ranking、Hybrid Search）
- 分析ダッシュボード

---

## 17. 用語集

| 用語 | 説明 |
|------|------|
| RAG | Retrieval-Augmented Generation。検索拡張生成。外部知識を検索してLLMの回答を補強する技術 |
| Embedding | テキストをベクトル表現に変換したもの |
| Chunk | ファイルを分割した小さなテキスト単位 |
| pgvector | PostgreSQLのベクトル検索拡張 |
| LlamaIndex | RAGフレームワークの一つ |
| JWT | JSON Web Token。認証トークンの形式 |
| RLS | Row Level Security。行レベルセキュリティ |

---

## 18. 参考資料

- [LlamaIndex Documentation](https://docs.llamaindex.ai/)
- [Supabase Documentation](https://supabase.com/docs)
- [Azure Functions Documentation](https://learn.microsoft.com/azure/azure-functions/)
- [pgvector Documentation](https://github.com/pgvector/pgvector)

---

## 19. プロジェクト構造

### 19.1 ディレクトリ構成

```
rag-base/
├── backend/                    # バックエンド（Azure Functions）
│   ├── app/
│   │   ├── __init__.py
│   │   ├── config/            # 設定管理
│   │   │   ├── __init__.py
│   │   │   └── settings.py
│   │   ├── core/              # コア機能
│   │   │   ├── __init__.py
│   │   │   ├── exceptions.py # 例外定義
│   │   │   ├── auth.py        # 認証・認可
│   │   │   └── logging.py     # ロギング
│   │   ├── models/            # データモデル（Lv2.5: 3テーブル分離）
│   │   │   ├── __init__.py
│   │   │   ├── file.py
│   │   │   ├── chunk.py
│   │   │   └── embedding.py
│   │   ├── repositories/      # データアクセス層（Lv2.5: 3テーブル分離）
│   │   │   ├── __init__.py
│   │   │   ├── file_repository.py
│   │   │   ├── chunk_repository.py
│   │   │   └── embedding_repository.py
│   │   ├── services/          # ビジネスロジック層
│   │   │   ├── __init__.py
│   │   │   ├── rag_service.py
│   │   │   ├── file_service.py
│   │   │   └── storage_service.py
│   │   └── api/               # APIエンドポイント
│   │       ├── __init__.py
│   │       ├── chat.py
│   │       ├── admin.py
│   │       └── health.py
│   ├── tests/                 # テスト
│   │   ├── unit/
│   │   ├── integration/
│   │   └── fixtures/
│   ├── migrations/            # DBマイグレーション
│   │   └── 001_initial_schema.sql
│   ├── requirements.txt       # Python依存関係
│   ├── pyproject.toml         # プロジェクト設定
│   ├── env.example            # 環境変数テンプレート
│   └── host.json              # Azure Functions設定
│
├── frontend/                  # フロントエンド（Azure Static Web Apps）
│   ├── index.html            # チャット画面（/）
│   ├── admin.html            # 管理画面（/admin）
│   ├── login.html            # ログイン画面（/login）
│   ├── css/
│   │   └── style.css
│   ├── js/
│   │   ├── auth.js           # 認証処理
│   │   ├── chat.js           # チャット機能
│   │   └── admin.js          # 管理機能
│   └── staticwebapp.config.json
│
├── docs/                      # ドキュメント
│   ├── api.md                # API仕様書
│   ├── deployment.md         # デプロイ手順
│   └── development.md        # 開発ガイド
│
├── scripts/                   # ユーティリティスクリプト
│   ├── setup_db.sh           # DBセットアップ
│   └── deploy.sh             # デプロイスクリプト
│
├── .gitignore
├── README.md
└── きそ.md                   # 本要件定義書
```

### 19.2 レイヤー別責務

| レイヤー | 責務 | 依存関係 |
|---------|------|----------|
| **API Layer** | HTTPリクエスト/レスポンス処理、認証・認可 | Services Layer |
| **Services Layer** | ビジネスロジック、RAG処理 | Repositories Layer |
| **Repositories Layer** | データアクセス（DB/Storage、Lv2.5: 3テーブル分離） | Models |
| **Models** | データ構造定義 | なし |

---

## 20. 開発環境セットアップ

### 20.1 前提条件

- Python 3.11以上
- Node.js 18以上（フロントエンド開発用）
- Azure Functions Core Tools v4
- Supabaseアカウント
- OpenAI APIキー

### 20.2 ローカル開発環境構築手順

#### ステップ1: リポジトリクローン

```bash
git clone <repository-url>
cd rag-base
```

#### ステップ2: バックエンド環境構築

```bash
cd backend

# 仮想環境作成
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 依存関係インストール
pip install -r requirements.txt

# 環境変数設定
cp env.example .env
# .envファイルを編集して実際の値を設定
```

#### ステップ3: データベースセットアップ

```bash
# Supabaseプロジェクトで以下を実行
# 1. pgvector拡張を有効化
# 2. migrations/001_initial_schema.sqlを実行
# 3. Storageバケット「documents」を作成
```

#### ステップ4: Azure Functionsローカル実行

```bash
# Azure Functions Core Toolsで起動
func start
```

#### ステップ5: フロントエンド開発

```bash
cd frontend

# ローカルサーバー起動（例: Python HTTPサーバー）
python -m http.server 3000
# または
npx serve .
```

### 20.3 開発時の注意事項

- 環境変数は`.env`ファイルで管理（`.gitignore`に追加）
- ローカルDB接続はSupabaseの接続文字列を使用
- CORS設定で`http://localhost:3000`を許可

---

## 21. データベースマイグレーション

### 21.1 初期スキーマ作成（Lv2.5: 3テーブル分離設計）

**ファイル**: `migrations/001_initial_schema.sql`

```sql
-- ============================================
-- RAG System 初期スキーマ（Lv2.5）
-- files + chunks + embeddings 3テーブル分離設計
-- ============================================

-- pgvector拡張を有効化
CREATE EXTENSION IF NOT EXISTS vector;

-- --------------------------------------------
-- filesテーブル: ファイルメタデータ
-- --------------------------------------------
CREATE TABLE files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  file_name TEXT NOT NULL,
  storage_path TEXT NOT NULL,
  file_size BIGINT,
  mime_type TEXT,
  status TEXT NOT NULL DEFAULT 'uploaded',
  -- status: 'uploaded' | 'indexing' | 'indexed' | 'error'
  error_message TEXT,
  chunk_count INTEGER DEFAULT 0,
  embedding_count INTEGER DEFAULT 0,
  -- embedding_count: 実際にEmbeddingが生成されたチャンク数
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  CONSTRAINT status_check CHECK (status IN ('uploaded', 'indexing', 'indexed', 'error'))
);

-- --------------------------------------------
-- chunksテーブル: テキストチャンク（Embeddingは含まない）
-- --------------------------------------------
CREATE TABLE chunks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  file_id UUID NOT NULL REFERENCES files(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  chunk_index INTEGER NOT NULL,
  -- chunk_index: ファイル内でのチャンクの順序（0始まり）
  token_count INTEGER,
  -- token_count: チャンクのトークン数（オプション、将来の最適化用）
  created_at TIMESTAMP DEFAULT now(),
  CONSTRAINT chunk_index_check CHECK (chunk_index >= 0)
);

-- --------------------------------------------
-- embeddingsテーブル: チャンクのベクトル表現
-- --------------------------------------------
CREATE TABLE embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chunk_id UUID NOT NULL REFERENCES chunks(id) ON DELETE CASCADE,
  embedding VECTOR(1536) NOT NULL,
  -- 1536次元: text-embedding-3-small
  model_name TEXT NOT NULL DEFAULT 'text-embedding-3-small',
  -- model_name: Embeddingモデル名（将来のモデル変更に対応）
  created_at TIMESTAMP DEFAULT now(),
  CONSTRAINT unique_chunk_embedding UNIQUE (chunk_id, model_name)
  -- 1チャンクにつき1モデルで1つのEmbedding（将来のマルチモデル対応）
);

-- --------------------------------------------
-- インデックス作成
-- --------------------------------------------
-- filesテーブルのインデックス
CREATE INDEX idx_files_status ON files(status);
CREATE INDEX idx_files_created_at ON files(created_at DESC);

-- chunksテーブルのインデックス
CREATE INDEX idx_chunks_file_id ON chunks(file_id);
CREATE INDEX idx_chunks_file_id_index ON chunks(file_id, chunk_index);

-- embeddingsテーブルのインデックス
CREATE INDEX idx_embeddings_chunk_id ON embeddings(chunk_id);
CREATE INDEX idx_embeddings_model ON embeddings(model_name);
-- ベクトル検索用インデックス（ivfflat）
CREATE INDEX idx_embeddings_vector ON embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- --------------------------------------------
-- コメント追加
-- --------------------------------------------
COMMENT ON TABLE files IS 'アップロードされたファイルのメタデータ';
COMMENT ON TABLE chunks IS 'ファイルを分割したテキストチャンク（Embeddingは別テーブル）';
COMMENT ON TABLE embeddings IS 'チャンクのベクトル表現（Embedding）';
COMMENT ON COLUMN files.status IS 'ファイルの処理ステータス: uploaded, indexing, indexed, error';
COMMENT ON COLUMN files.embedding_count IS '実際にEmbeddingが生成されたチャンク数';
COMMENT ON COLUMN chunks.chunk_index IS 'ファイル内でのチャンクの順序（0始まり）';
COMMENT ON COLUMN embeddings.model_name IS 'Embeddingモデル名（将来のモデル変更・比較に対応）';
COMMENT ON COLUMN embeddings.embedding IS 'ベクトル表現（1536次元、text-embedding-3-small）';
```

### 21.2 マイグレーション実行手順

1. Supabase Dashboard → SQL Editorを開く
2. `migrations/001_initial_schema.sql`の内容をコピー
3. SQL Editorで実行
4. 実行結果を確認

### 21.3 将来のマイグレーション

- バージョン管理: `migrations/002_<feature>.sql`形式で管理
- ロールバック: 各マイグレーションに対応するロールバックスクリプトを用意

---

## 22. ファイル処理詳細仕様

### 22.1 対応ファイル形式

#### 22.1.1 テキストファイル（.txt）

**処理方法**:
- エンコーディング検出（UTF-8優先）
- そのままテキストとして読み込み
- 改行コードを統一（`\n`）

**制約**:
- 最大ファイルサイズ: 10MB
- エンコーディング: UTF-8, Shift-JIS, EUC-JP

#### 22.1.2 Markdownファイル（.md）

**処理方法**:
- UTF-8エンコーディングで読み込み
- Markdown記法はそのまま保持
- チャンキング時は段落区切り（`\n\n`）を優先

**制約**:
- 最大ファイルサイズ: 10MB

#### 22.1.3 PDFファイル（.pdf）

**処理方法**:
- `pdfplumber`または`pypdf`を使用してテキスト抽出
- ページ単位で処理
- 画像・表は無視（テキストのみ）

**制約**:
- 最大ファイルサイズ: 10MB
- 最大ページ数: 100ページ
- スキャンされたPDF（画像のみ）は非対応

**エラーハンドリング**:
- テキスト抽出失敗時は`EXTRACTION_FAILED`エラー
- パスワード保護PDFは非対応

### 22.2 チャンキング戦略の詳細

#### 22.2.1 基本パラメータ

- **chunk_size**: 500文字（設定可能）
- **chunk_overlap**: 50文字（設定可能）
- **separator**: `\n\n`（段落区切り）

#### 22.2.2 チャンキングアルゴリズム

1. ファイル全体を読み込み
2. 段落区切り（`\n\n`）で分割
3. 各段落が`chunk_size`を超える場合、さらに分割
4. 分割時に`chunk_overlap`分の文字を重複させる
5. 各チャンクに`chunk_index`を付与（0始まり）

#### 22.2.3 特殊ケース

- **空のチャンク**: スキップ
- **非常に短いチャンク（<50文字）**: 次のチャンクと結合
- **非常に長いチャンク（>2000文字）**: 強制的に分割

---

## 23. APIリクエスト/レスポンス詳細

### 23.1 共通ヘッダー

**リクエストヘッダー**:
```
Content-Type: application/json
Authorization: Bearer <jwt_token>
```

**レスポンスヘッダー**:
```
Content-Type: application/json
X-Request-ID: <uuid>  # リクエスト追跡用
```

### 23.2 エラーレスポンス詳細

**形式**:
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "エラーメッセージ（ユーザー向け）",
    "details": {
      "field": "エラーが発生したフィールド名",
      "reason": "技術的な理由（開発環境のみ）"
    },
    "request_id": "uuid"
  }
}
```

**例**:
```json
{
  "error": {
    "code": "INVALID_FILE_TYPE",
    "message": "サポートされていないファイル形式です",
    "details": {
      "field": "file",
      "reason": "File extension '.docx' is not supported. Supported: .txt, .md, .pdf"
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

### 23.3 バリデーションルール

#### POST /api/chat

| フィールド | 型 | 必須 | 制約 |
|-----------|-----|------|------|
| message | string | 必須 | 1-2000文字 |

#### POST /api/admin/upload

| フィールド | 型 | 必須 | 制約 |
|-----------|-----|------|------|
| file | file | 必須 | 10MB以下、.txt/.md/.pdf |

#### POST /api/admin/delete

| フィールド | 型 | 必須 | 制約 |
|-----------|-----|------|------|
| file_id | string (UUID) | 必須 | 有効なUUID形式 |

---

## 24. 実装ガイドライン

### 24.1 コーディング規約

- **Python**: PEP 8準拠、型ヒント必須
- **命名規則**:
  - クラス: PascalCase（例: `RAGService`）
  - 関数・変数: snake_case（例: `get_file_by_id`）
  - 定数: UPPER_SNAKE_CASE（例: `MAX_FILE_SIZE`）

### 24.2 エラーハンドリング原則

1. **例外は適切な階層でキャッチ**
   - API層: HTTP例外に変換
   - Service層: ビジネス例外をスロー
   - Repository層: DB例外をキャッチ

2. **エラーログは必ず記録**
   - エラーコード、メッセージ、スタックトレース
   - リクエストIDを含める

3. **ユーザー向けメッセージは分かりやすく**
   - 技術的詳細は`details`に含める

### 24.3 テスト方針

- **単体テスト**: 各関数・メソッドをテスト
- **統合テスト**: APIエンドポイントをテスト
- **カバレッジ目標**: 80%以上

### 24.4 ロギング方針

- **レベル**: DEBUG（開発）、INFO（本番）
- **フォーマット**: JSON（本番）、テキスト（開発）
- **出力先**: 標準出力（Azure Functionsのログストリーム）

---

## 25. デプロイ手順詳細

### 25.1 Supabaseセットアップ

1. **プロジェクト作成**
   - Supabase Dashboardで新規プロジェクト作成
   - リージョン選択（日本: ap-northeast-1推奨）

2. **データベース設定**
   - SQL Editorで`migrations/001_initial_schema.sql`を実行
   - pgvector拡張が有効化されていることを確認

3. **Storage設定**
   - Storage → Buckets → New bucket
   - バケット名: `documents`
   - Public: 無効（認証必須）
   - ポリシー設定: 認証済みユーザーのみアクセス可能

4. **認証設定**
   - Auth → Settings → Email認証を有効化
   - パスワード要件設定（最小8文字）

### 25.2 Azure Functionsデプロイ

1. **Function App作成**
   ```bash
   az functionapp create \
     --resource-group <resource-group> \
     --consumption-plan-location japaneast \
     --runtime python \
     --runtime-version 3.11 \
     --functions-version 4 \
     --name <function-app-name> \
     --storage-account <storage-account-name>
   ```

2. **環境変数設定**
   ```bash
   az functionapp config appsettings set \
     --name <function-app-name> \
     --resource-group <resource-group> \
     --settings \
       SUPABASE_URL="<url>" \
       SUPABASE_ANON_KEY="<key>" \
       # ... その他の環境変数
   ```

3. **デプロイ**
   ```bash
   cd backend
   func azure functionapp publish <function-app-name>
   ```

### 25.3 Azure Static Web Appsデプロイ

1. **Static Web App作成**
   ```bash
   az staticwebapp create \
     --name <static-web-app-name> \
     --resource-group <resource-group> \
     --location japaneast \
     --sku Free
   ```

2. **GitHub Actions設定**
   - リポジトリに`.github/workflows/azure-static-web-apps-<name>.yml`が自動生成
   - ビルド設定を確認

3. **デプロイ**
   - GitHubにpushすると自動デプロイ
   - または`swa deploy`コマンドで手動デプロイ

### 25.4 デプロイ後確認

- [ ] APIヘルスチェック: `GET /api/health`
- [ ] 認証動作確認: ログイン→チャット
- [ ] 管理者機能確認: ファイルアップロード→削除
- [ ] エラーログ確認: Azure Portalでログを確認

---

## 26. トラブルシューティング

### 26.1 よくある問題

#### 問題1: データベース接続エラー

**症状**: `DATABASE_ERROR`が発生

**原因**:
- 接続文字列が間違っている
- ファイアウォール設定でIPがブロックされている

**解決方法**:
1. `.env`の接続情報を確認
2. Supabase Dashboard → Settings → Database → Connection stringを確認
3. 必要に応じてIPを許可リストに追加

#### 問題2: Embedding生成が遅い

**症状**: ファイルアップロードに時間がかかる

**原因**:
- OpenAI APIのレート制限
- チャンク数が多い

**解決方法**:
1. バッチ処理でEmbedding生成を最適化
2. リトライロジックを実装
3. 非同期処理に変更（将来実装）

#### 問題3: ベクトル検索結果が0件

**症状**: RAG検索で`NO_RESULTS`が返る

**原因**:
- インデックスが作成されていない
- 類似度閾値が高すぎる

**解決方法**:
1. `files`テーブルで`status='indexed'`のファイルが存在するか確認
2. `chunks`テーブルにデータが存在するか確認
3. 類似度閾値を調整（必要に応じて）

### 26.2 ログ確認方法

**Azure Functions**:
```bash
az functionapp log tail --name <function-app-name> --resource-group <resource-group>
```

**Supabase**:
- Dashboard → Logs → Postgres Logs

---

## 27. パフォーマンス最適化

### 27.1 データベース最適化

- **インデックス**: `chunks.embedding`にivfflatインデックスを作成
- **接続プール**: 適切な接続プールサイズを設定
- **クエリ最適化**: JOINを最小限に

### 27.2 RAG処理最適化

- **Embeddingバッチ処理**: 複数チャンクを一度に処理
- **キャッシュ**: 同じ質問のEmbeddingをキャッシュ（将来実装）
- **並列処理**: チャンキングとEmbedding生成を並列化（将来実装）

### 27.3 API最適化

- **タイムアウト設定**: 適切なタイムアウト値
- **リトライ**: 一時的なエラーに対するリトライ
- **レート制限**: ユーザー単位のレート制限（将来実装）

---

## 28. セキュリティチェックリスト

### 28.1 認証・認可

- [ ] JWT検証がすべてのエンドポイントで実装されている
- [ ] 管理者判定が正しく動作している
- [ ] トークンの有効期限が適切に設定されている

### 28.2 データ保護

- [ ] SQLインジェクション対策（パラメータ化クエリ）
- [ ] XSS対策（入力値サニタイズ）
- [ ] ファイルアップロードの検証（形式・サイズ）

### 28.3 インフラ

- [ ] CORS設定が適切
- [ ] 環境変数が漏洩していない
- [ ] ストレージバケットのアクセス制御が適切

---

## 19. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|----------|--------|
| 1.0 | 2024-01-01 | 初版作成 | - |
| 1.1 | 2024-01-XX | プロジェクト構造、開発環境、デプロイ手順を追加 | - |

---

**文書終了**
